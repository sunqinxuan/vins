/***********************************************
#
# Author: Sun Qinxuan
#
# Email: sunqinxuan@outlook.com
#
# Last modified:	2021-11-11 10:47
#
# Filename:		vertex_pose.hpp
#
# Description:
#
************************************************/

#ifndef VSLAM_OPTIMIZER_VERTEX_HPP_
#define VSLAM_OPTIMIZER_VERTEX_HPP_

#include <eigen3/Eigen/Dense>
#include <ceres/ceres.h>
#include "tools/geometry.hpp"

namespace vslam
{
//using Matrix6d = Eigen::Matrix<double, 6, 6>;
using Vector7d = Eigen::Matrix<double, 7, 1>;
using Vector9d = Eigen::Matrix<double, 9, 1>;

class VertexParamNavState
{
public:
  VertexParamNavState()=delete;
  VertexParamNavState(const NavState &nav_state,const IMUBias &bias, bool fix=false) : fixed(fix)
  {
		pose(0)=nav_state.position().x();
		pose(1)=nav_state.position().y();
		pose(2)=nav_state.position().z();
		pose(3)=nav_state.quaternion().x();
		pose(4)=nav_state.quaternion().y();
		pose(5)=nav_state.quaternion().z();
		pose(6)=nav_state.quaternion().w();

		vel_bias(0)=nav_state.velocity().x();
		vel_bias(1)=nav_state.velocity().y();
		vel_bias(2)=nav_state.velocity().z();
		vel_bias.tail<6>()=bias;
    //position = pose.translation();
    //quaternion = Eigen::Quaterniond(pose.linear());
    //quaternion.normalize();
    //xi = Sophus::SE3(quaternion.normalized(), position).log();
  }

  //unsigned int id;
  //Eigen::Vector3d position;
  //Eigen::Quaterniond quaternion;
  //Matrix6d covariance;

  //Vector6d xi;

	Vector7d pose;
	Vector9d vel_bias;
  bool fixed;

  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
};

class VertexParamFeature
{
public:
  VertexParamFeature()=delete;
  VertexParamFeature(const double d, bool fix=false) : fixed(fix)
  {
		depth
  }

  //unsigned int id;
  //Eigen::Vector3d position;
  //Eigen::Quaterniond quaternion;
  //Matrix6d covariance;

  //Vector6d xi;

	Vector7d pose;
	Vector9d vel_bias;
  bool fixed;

  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
};

//class SE3Parameterization : public ceres::LocalParameterization
//{
//public:
//  SE3Parameterization()
//  {
//  }
//  virtual ~SE3Parameterization()
//  {
//  }
//
//  virtual bool Plus(const double *x, const double *delta, double *x_plus_delta) const
//  {
//    Eigen::Map<const Eigen::Matrix<double, 6, 1>> lie(x);
//    Eigen::Map<const Eigen::Matrix<double, 6, 1>> delta_lie(delta);
//
//    Sophus::SE3 T = Sophus::SE3::exp(lie);
//    Sophus::SE3 delta_T = Sophus::SE3::exp(delta_lie);
//
//    Eigen::Matrix<double, 6, 1> x_plus_delta_lie = (delta_T * T).log();
//
//    for (int i = 0; i < 6; ++i) {
//      x_plus_delta[i] = x_plus_delta_lie(i, 0);
//    }
//
//    return true;
//  }
//  virtual bool ComputeJacobian(const double *x, double *jacobian) const
//  {
//    ceres::MatrixRef(jacobian, 6, 6) = ceres::Matrix::Identity(6, 6);
//    return true;
//  }
//  virtual int GlobalSize() const
//  {
//    return 6;
//  }
//  virtual int LocalSize() const
//  {
//    return 6;
//  }
//};

}  // namespace vision_localization
#endif
